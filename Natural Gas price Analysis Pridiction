import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from scipy.interpolate import interp1d
from sklearn.linear_model import LinearRegression
import warnings
warnings.filterwarnings('ignore')

class GasPricePredictor:
    """
    Natural Gas Price Analysis and Prediction System
    Analyzes historical monthly gas prices and extrapolates future prices
    """

    def __init__(self, csv_file=None):
        """Initialize with optional CSV file path"""
        self.data = None
        self.prices = None
        self.dates = None
        self.interpolator = None
        self.seasonal_model = None
        self.trend_model = None

        if csv_file:
            self.load_data(csv_file)

    def load_data(self, csv_file):
        """Load natural gas price data from CSV file"""
        try:
            self.data = pd.read_csv(csv_file)

            # Assume the CSV has 'Date' and 'Price' columns
            # Adjust column names based on actual CSV structure
            if 'Date' in self.data.columns:
                self.data['Date'] = pd.to_datetime(self.data['Date'])
            elif 'date' in self.data.columns:
                self.data['Date'] = pd.to_datetime(self.data['date'])
            else:
                # Use first column as date
                self.data['Date'] = pd.to_datetime(self.data.iloc[:, 0])

            # Get price column
            price_cols = [col for col in self.data.columns if 'price' in col.lower() or 'value' in col.lower()]
            if price_cols:
                self.data['Price'] = self.data[price_cols[0]]
            else:
                # Use second column as price
                self.data['Price'] = self.data.iloc[:, 1]

            self.data = self.data.sort_values('Date').reset_index(drop=True)
            self.dates = self.data['Date'].values
            self.prices = self.data['Price'].values

            print(f"Data loaded successfully: {len(self.data)} records")
            print(f"Date range: {self.data['Date'].min()} to {self.data['Date'].max()}")

        except Exception as e:
            print(f"Error loading data: {e}")
            self._generate_sample_data()

    def _generate_sample_data(self):
        """Generate sample data for demonstration if CSV not available"""
        print("Generating sample natural gas price data...")

        # Create date range from Oct 2020 to Sep 2024
        start_date = datetime(2020, 10, 31)
        dates = []
        current = start_date

        while current <= datetime(2024, 9, 30):
            dates.append(current)
            # Move to end of next month
            if current.month == 12:
                current = datetime(current.year + 1, 1, 31)
            else:
                next_month = current.month + 1
                # Handle different month lengths
                try:
                    current = datetime(current.year, next_month, 31)
                except ValueError:
                    try:
                        current = datetime(current.year, next_month, 30)
                    except ValueError:
                        try:
                            current = datetime(current.year, next_month, 29)
                        except ValueError:
                            current = datetime(current.year, next_month, 28)

        # Generate realistic prices with seasonal patterns and trend
        np.random.seed(42)
        n = len(dates)
        t = np.arange(n)

        # Base price with upward trend
        base = 2.5 + 0.02 * t

        # Seasonal component (higher in winter, lower in summer)
        months = np.array([d.month for d in dates])
        seasonal = 0.8 * np.sin(2 * np.pi * (months - 1) / 12 + np.pi/2)

        # Random noise
        noise = np.random.normal(0, 0.3, n)

        # Combine components
        prices = base + seasonal + noise
        prices = np.maximum(prices, 1.0)  # Ensure positive prices

        self.data = pd.DataFrame({
            'Date': dates,
            'Price': prices
        })

        self.dates = self.data['Date'].values
        self.prices = self.data['Price'].values

        print(f"Sample data generated: {len(self.data)} records")

    def analyze_data(self):
        """Analyze the data for patterns and trends"""
        self.data['Month'] = self.data['Date'].dt.month
        self.data['Year'] = self.data['Date'].dt.year

        # Calculate basic statistics
        print("\n=== Price Statistics ===")
        print(f"Mean Price: ${self.data['Price'].mean():.2f}")
        print(f"Median Price: ${self.data['Price'].median():.2f}")
        print(f"Min Price: ${self.data['Price'].min():.2f}")
        print(f"Max Price: ${self.data['Price'].max():.2f}")
        print(f"Std Dev: ${self.data['Price'].std():.2f}")

        # Seasonal analysis
        print("\n=== Seasonal Analysis (Average Price by Month) ===")
        seasonal_avg = self.data.groupby('Month')['Price'].mean().sort_index()
        for month, price in seasonal_avg.items():
            month_name = datetime(2020, month, 1).strftime('%B')
            print(f"{month_name}: ${price:.2f}")

        # Year-over-year analysis
        print("\n=== Year-over-Year Analysis ===")
        yearly_avg = self.data.groupby('Year')['Price'].mean().sort_index()
        for year, price in yearly_avg.items():
            print(f"{year}: ${price:.2f}")

    def build_prediction_model(self):
        """Build a model combining trend and seasonal components"""
        # Convert dates to numeric (days since first observation)
        first_date = pd.Timestamp(self.dates[0])
        numeric_dates = np.array([(pd.Timestamp(d) - first_date).days for d in self.dates])

        # Extract seasonal features
        months = np.array([pd.Timestamp(d).month for d in self.dates])

        # Create seasonal features (sin and cos for cyclical nature)
        seasonal_sin = np.sin(2 * np.pi * months / 12)
        seasonal_cos = np.cos(2 * np.pi * months / 12)

        # Build feature matrix
        X = np.column_stack([
            numeric_dates,
            seasonal_sin,
            seasonal_cos
        ])

        # Fit linear regression model
        self.trend_model = LinearRegression()
        self.trend_model.fit(X, self.prices)

        print("\n=== Model Built Successfully ===")
        print(f"Model RÂ² Score: {self.trend_model.score(X, self.prices):.4f}")

    def get_price(self, input_date):
        """
        Get estimated price for any date (past or future)

        Args:
            input_date: datetime object, string ('YYYY-MM-DD'), or timestamp

        Returns:
            Estimated price as float
        """
        # Convert input to datetime
        if isinstance(input_date, str):
            query_date = pd.to_datetime(input_date)
        elif isinstance(input_date, datetime):
            query_date = pd.Timestamp(input_date)
        else:
            query_date = pd.Timestamp(input_date)

        # Calculate numeric date
        first_date = pd.Timestamp(self.dates[0])
        numeric_date = (query_date - first_date).days

        # Extract seasonal features
        month = query_date.month
        seasonal_sin = np.sin(2 * np.pi * month / 12)
        seasonal_cos = np.cos(2 * np.pi * month / 12)

        # Prepare feature vector
        X = np.array([[numeric_date, seasonal_sin, seasonal_cos]])

        # Predict price
        predicted_price = self.trend_model.predict(X)[0]

        # Ensure positive price
        predicted_price = max(predicted_price, 0.5)

        return predicted_price

    def visualize(self):
        """Create comprehensive visualizations of the data and predictions"""
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        fig.suptitle('Natural Gas Price Analysis', fontsize=16, fontweight='bold')

        # 1. Historical prices with trend
        ax1 = axes[0, 0]
        ax1.plot(self.data['Date'], self.data['Price'], 'o-', label='Historical Prices', markersize=4)

        # Add future predictions
        last_date = self.data['Date'].max()
        future_dates = pd.date_range(start=last_date + timedelta(days=30),
                                      periods=12, freq='M')
        future_prices = [self.get_price(d) for d in future_dates]

        ax1.plot(future_dates, future_prices, 's--', color='red',
                label='Extrapolated Prices', markersize=6)
        ax1.set_xlabel('Date')
        ax1.set_ylabel('Price ($/unit)')
        ax1.set_title('Historical and Predicted Prices')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        ax1.tick_params(axis='x', rotation=45)

        # 2. Seasonal pattern
        ax2 = axes[0, 1]
        seasonal_avg = self.data.groupby('Month')['Price'].mean()
        months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
        ax2.bar(range(1, 13), seasonal_avg, color='skyblue', edgecolor='navy')
        ax2.set_xlabel('Month')
        ax2.set_ylabel('Average Price ($/unit)')
        ax2.set_title('Seasonal Price Pattern')
        ax2.set_xticks(range(1, 13))
        ax2.set_xticklabels(months, rotation=45)
        ax2.grid(True, alpha=0.3, axis='y')

        # 3. Year-over-year comparison
        ax3 = axes[1, 0]
        for year in self.data['Year'].unique():
            year_data = self.data[self.data['Year'] == year]
            ax3.plot(year_data['Month'], year_data['Price'], 'o-', label=str(year), markersize=4)
        ax3.set_xlabel('Month')
        ax3.set_ylabel('Price ($/unit)')
        ax3.set_title('Year-over-Year Comparison')
        ax3.legend()
        ax3.grid(True, alpha=0.3)
        ax3.set_xticks(range(1, 13))

        # 4. Price distribution
        ax4 = axes[1, 1]
        ax4.hist(self.data['Price'], bins=20, color='lightgreen', edgecolor='darkgreen', alpha=0.7)
        ax4.axvline(self.data['Price'].mean(), color='red', linestyle='--',
                   linewidth=2, label=f"Mean: ${self.data['Price'].mean():.2f}")
        ax4.axvline(self.data['Price'].median(), color='blue', linestyle='--',
                   linewidth=2, label=f"Median: ${self.data['Price'].median():.2f}")
        ax4.set_xlabel('Price ($/unit)')
        ax4.set_ylabel('Frequency')
        ax4.set_title('Price Distribution')
        ax4.legend()
        ax4.grid(True, alpha=0.3, axis='y')

        plt.tight_layout()
        plt.show()

    def demonstrate(self):
        """Demonstrate the predictor with various dates"""
        print("\n=== Price Prediction Demonstration ===")

        # Test historical dates
        test_dates = [
            '2021-06-30',  # Historical
            '2023-12-31',  # Historical
            '2024-09-30',  # Last known
            '2024-12-31',  # Future
            '2025-06-30',  # Future
            '2025-09-30',  # Future (1 year ahead)
        ]

        for date_str in test_dates:
            price = self.get_price(date_str)
            date_obj = pd.to_datetime(date_str)
            is_future = date_obj > pd.Timestamp(self.dates[-1])
            flag = "(EXTRAPOLATED)" if is_future else "(Historical)"
            print(f"{date_str}: ${price:.2f} {flag}")


# Main execution
if __name__ == "__main__":
    print("Natural Gas Price Analysis System")
    print("=" * 50)

    # Initialize predictor
    # Replace 'gas_prices.csv' with your actual CSV file path
    predictor = GasPricePredictor('gas_prices.csv')

    # Analyze the data
    predictor.analyze_data()

    # Build prediction model
    predictor.build_prediction_model()

    # Demonstrate predictions
    predictor.demonstrate()

    # Visualize
    predictor.visualize()

    # Interactive usage example
    print("\n=== Interactive Usage ===")
    print("You can now use the predictor for any date:")
    print("Example: price = predictor.get_price('2025-12-31')")

    # Example of getting a specific price
    example_date = '2025-03-31'
    example_price = predictor.get_price(example_date)
    print(f"\nExample: Price on {example_date} = ${example_price:.2f}")
